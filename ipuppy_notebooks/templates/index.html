{% extends "base.html" %}

{% block content %}
<div class="row">
    <div class="col-md-3" id="sidebar">
        <div class="card mb-3">
            <div class="card-header">
                <h5>Notebooks</h5>
            </div>
            <div class="card-body">
                <div id="file-list">
                    <!-- File list will be populated here -->
                </div>
                <div class="mt-3">
                    <div class="input-group">
                        <input type="text" class="form-control" id="new-notebook-name" placeholder="Notebook name">
                        <button class="btn btn-primary" type="button" id="create-notebook-btn">
                            <i class="fas fa-plus"></i> Create
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header">
                <h5>Kernel Status</h5>
            </div>
            <div class="card-body">
                <div id="kernel-status" class="kernel-status idle">
                    Idle
                </div>
                <div class="mt-2">
                    <button class="btn btn-sm btn-success" id="start-kernel-btn">
                        <i class="fas fa-play"></i> Start
                    </button>
                    <button class="btn btn-sm btn-danger" id="stop-kernel-btn">
                        <i class="fas fa-stop"></i> Stop
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-9">
        <div id="notebook-container">
            <div class="text-center mt-5">
                <h3>Welcome to iPuppy Notebooks!</h3>
                <p class="text-secondary">Select a notebook or create a new one to get started</p>
                <i class="fas fa-paw fa-3x"></i>
            </div>
        </div>
        
        <button class="btn btn-success add-cell-btn" id="add-cell-btn" style="display: none;">
            <i class="fas fa-plus"></i> Add Cell
        </button>
    </div>
</div>

<div id="alert-container" class="position-fixed top-0 end-0 p-3" style="z-index: 1050;">
    <!-- Alerts will be shown here -->
</div>

<script>
    // Store references to CodeMirror instances
    const codeMirrorEditors = [];
    
    // Load notebooks on page load
    document.addEventListener('DOMContentLoaded', async function() {
        await loadNotebooks();
        
        // Set up event listeners
        document.getElementById('create-notebook-btn').addEventListener('click', createNotebook);
        document.getElementById('start-kernel-btn').addEventListener('click', startKernel);
        document.getElementById('stop-kernel-btn').addEventListener('click', stopKernel);
        document.getElementById('add-cell-btn').addEventListener('click', addCell);
    });
    
    async function loadNotebooks() {
        try {
            const response = await apiRequest('/api/v1/notebooks');
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '';
            
            response.notebooks.forEach(notebook => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <span>${notebook}</span>
                        <div>
                            <button class="btn btn-sm btn-success me-1" onclick="openNotebook('${notebook}')">
                                <i class="fas fa-play"></i>
                            </button>
                            <button class="btn btn-sm btn-danger" onclick="deleteNotebook('${notebook}')">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
                fileList.appendChild(fileItem);
            });
        } catch (error) {
            console.error('Failed to load notebooks:', error);
        }
    }
    
    async function createNotebook() {
        const nameInput = document.getElementById('new-notebook-name');
        const notebookName = nameInput.value.trim();
        
        if (!notebookName) {
            showAlert('Please enter a notebook name', 'warning');
            return;
        }
        
        // ensure .py extension only once
        if (!notebookName.endsWith('.py')) {
            nameInput.value = notebookName + '.py';
        }
        
        try {
            await apiRequest(`/api/v1/notebooks/${nameInput.value}`, 'POST');
            showAlert(`Notebook ${nameInput.value} created successfully`, 'success');
            nameInput.value = '';
            await loadNotebooks();
        } catch (error) {
            showAlert(`Failed to create notebook: ${error.message}`, 'danger');
        }
    }
    
    async function deleteNotebook(notebookName) {
        if (!confirm(`Are you sure you want to delete ${notebookName}?`)) {
            return;
        }
        
        try {
            await apiRequest(`/api/v1/notebooks/${notebookName}`, 'DELETE');
            showAlert(`Notebook ${notebookName} deleted successfully`, 'success');
            await loadNotebooks();
            
            // If we're currently viewing this notebook, close it
            const notebookNameSpan = document.getElementById('current-notebook-name');
            const saveButton = document.getElementById('save-notebook-btn');
            if (notebookNameSpan && saveButton && notebookNameSpan.textContent === notebookName) {
                document.getElementById('notebook-container').innerHTML = `
                    <div class="text-center mt-5">
                        <h3>Welcome to iPuppy Notebooks!</h3>
                        <p class="text-secondary">Select a notebook or create a new one to get started</p>
                        <i class="fas fa-paw fa-3x"></i>
                    </div>
                `;
                document.getElementById('add-cell-btn').style.display = 'none';
                
                // Hide the notebook name and save button in the header
                notebookNameSpan.style.display = 'none';
                saveButton.style.display = 'none';
                notebookNameSpan.textContent = '';
            }
        } catch (error) {
            showAlert(`Failed to delete notebook: ${error.message}`, 'danger');
        }
    }
    
    async function openNotebook(notebookName) {
        try {
            const notebook = await apiRequest(`/api/v1/notebooks/${notebookName}`);
            renderNotebook(notebookName, notebook);
        } catch (error) {
            showAlert(`Failed to open notebook: ${error.message}`, 'danger');
        }
    }
    
    function renderNotebook(notebookName, notebook) {
        const container = document.getElementById('notebook-container');
        container.innerHTML = `
            <div id="cells-container">
                <!-- Cells will be rendered here -->
            </div>
        `;
        
        // Update the header with the current notebook name and save button
        const notebookNameSpan = document.getElementById('current-notebook-name');
        const saveButton = document.getElementById('save-notebook-btn');
        
        if (notebookNameSpan && saveButton) {
            notebookNameSpan.textContent = notebookName;
            notebookNameSpan.style.display = 'block';
            saveButton.style.display = 'block';
            
            // Remove any existing event listener
            saveButton.replaceWith(saveButton.cloneNode(true));
            
            // Add new event listener
            document.getElementById('save-notebook-btn').addEventListener('click', () => saveNotebook(notebookName));
        }
        
        const cellsContainer = document.getElementById('cells-container');
        notebook.cells.forEach((cell, index) => {
            cellsContainer.appendChild(createCellElement(cell, index));
        });
        
        // Initialize CodeMirror for all code cells
        initializeCodeMirrorEditors();
        
        // Show the add cell button
        document.getElementById('add-cell-btn').style.display = 'block';
    }
    
    function createCellElement(cell, index) {
        const cellDiv = document.createElement('div');
        cellDiv.className = 'notebook-cell card';
        cellDiv.dataset.cellIndex = index;
        
        // Create the cell header
        const cellHeader = document.createElement('div');
        cellHeader.className = 'cell-header';
        
        // Create select element
        const select = document.createElement('select');
        select.className = 'form-select form-select-sm';
        select.style.width = 'auto';
        select.innerHTML = `
            <option value="code" ${cell.cell_type === 'code' ? 'selected' : ''}>Code</option>
            <option value="markdown" ${cell.cell_type === 'markdown' ? 'selected' : ''}>Markdown</option>
        `;
        
        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        // Create execute button
        const executeBtn = document.createElement('button');
        executeBtn.className = 'btn btn-sm btn-success execute-btn';
        executeBtn.innerHTML = '<i class="fas fa-play"></i> Run';
        executeBtn.onclick = () => executeCell(index);
        
        buttonContainer.appendChild(executeBtn);
        
        // Create edit button for markdown cells
        if (cell.cell_type === 'markdown') {
            const editBtn = document.createElement('button');
            editBtn.className = 'btn btn-sm btn-secondary edit-btn ms-1';
            editBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
            editBtn.onclick = () => toggleMarkdownEditMode(cellDiv);
            buttonContainer.appendChild(editBtn);
        }
        
        cellHeader.appendChild(select);
        cellHeader.appendChild(buttonContainer);
        
        // Create the cell content area
        const cellContent = document.createElement('div');
        cellContent.className = 'cell-content';
        
        if (cell.cell_type === 'markdown') {
            // For markdown cells, create both edit and view areas
            // Initially show the rendered view and hide the textarea
            const markdownContent = cell.source.join('');
            cellContent.innerHTML = `
                <textarea class="form-control markdown-edit" rows="5" style="display: none;">${markdownContent}</textarea>
                <div class="markdown-view">${marked.parse(markdownContent)}</div>
            `;
        } else {
            // For code cells, create a textarea that will be converted to CodeMirror
            cellContent.innerHTML = `
                <textarea class="form-control code-cell" rows="5">${cell.source.join('')}</textarea>
            `;
        }
        
        // Create the cell output area
        const cellOutput = document.createElement('div');
        cellOutput.className = 'cell-output';
        cellOutput.innerHTML = cell.outputs ? cell.outputs.map(output => formatOutput(output)).join('') : 'No output yet';
        
        // Assemble the cell
        cellDiv.appendChild(cellHeader);
        cellDiv.appendChild(cellContent);
        cellDiv.appendChild(cellOutput);
        
        return cellDiv;
    }
    
    function formatOutput(output) {
        if (output.output_type === 'stream') {
            // text is already a string for stream outputs
            return output.text || 'No output';
        } else if (output.output_type === 'execute_result') {
            // Handle both string and array cases for text/plain data
            const textData = output.data['text/plain'];
            if (Array.isArray(textData)) {
                return textData.join('');
            } else if (typeof textData === 'string') {
                return textData;
            } else {
                return 'Result';
            }
        } else if (output.output_type === 'error') {
            // Format error messages with better styling
            // text is already formatted as a string in the executor
            return `<div class="text-danger">${output.text}</div>`;
        } else if (output.data && output.data['text/plain']) {
            // Handle both string and array cases for text/plain data
            const textData = output.data['text/plain'];
            if (Array.isArray(textData)) {
                return textData.join('');
            } else if (typeof textData === 'string') {
                return textData;
            } else {
                return 'Output';
            }
        } else {
            return 'Output';
        }
    }
    
    function addCell() {
        const cellsContainer = document.getElementById('cells-container');
        if (!cellsContainer) return;
        
        const newCell = {
            cell_type: 'code',
            source: [],
            outputs: []
        };
        
        const cellElement = createCellElement(newCell, cellsContainer.children.length);
        cellsContainer.appendChild(cellElement);
        
        // Initialize CodeMirror for the new cell if it's a code cell
        if (newCell.cell_type === 'code') {
            initializeCodeMirrorForElement(cellElement);
        }
    }
    
    async function executeCell(cellIndex) {
        const cellsContainer = document.getElementById('cells-container');
        if (!cellsContainer) return;
        
        const cellElement = cellsContainer.children[cellIndex];
        if (!cellElement) return;
        
        const cellType = cellElement.querySelector('select').value;
        const textarea = cellElement.querySelector('textarea');
        const outputDiv = cellElement.querySelector('.cell-output');
        const executeBtn = cellElement.querySelector('.execute-btn');
        
        if (!textarea || !outputDiv || !executeBtn) return;
        
        // Get code from CodeMirror editor if it exists
        let code = '';
        if (cellType === 'code') {
            const cmEditor = cellElement.querySelector('.CodeMirror');
            if (cmEditor) {
                const cmInstance = cmEditor.CodeMirror;
                code = cmInstance.getValue();
            } else {
                code = textarea.value;
            }
        } else {
            code = textarea.value;
        }
        
        if (!code.trim()) {
            showAlert('Cell is empty', 'warning');
            return;
        }
        
        // Handle markdown cells differently
        if (cellType === 'markdown') {
            const markdownView = cellElement.querySelector('.markdown-view');
            if (markdownView) {
                markdownView.innerHTML = marked.parse(code);
                // Switch to view mode
                textarea.style.display = 'none';
                markdownView.style.display = 'block';
            }
            return;
        }
        
        // Show loading state for code cells
        const originalText = executeBtn.innerHTML;
        executeBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Running';
        executeBtn.disabled = true;
        
        try {
            const outputs = await executeCode(code);
            if (outputs) {
                outputDiv.innerHTML = outputs.map(output => formatOutput(output)).join('');
            }
        } catch (error) {
            outputDiv.innerHTML = `<div class="text-danger">Error: ${error.message}</div>`;
        } finally {
            // Restore button state
            executeBtn.innerHTML = originalText;
            executeBtn.disabled = false;
        }
    }
    
    function toggleMarkdownEditMode(cellElement) {
        const textarea = cellElement.querySelector('.markdown-edit');
        const markdownView = cellElement.querySelector('.markdown-view');
        const editBtn = cellElement.querySelector('.edit-btn');
        
        if (!textarea || !markdownView || !editBtn) return;
        
        // Toggle between edit and view modes
        if (textarea.style.display === 'none') {
            // Switch to edit mode
            textarea.style.display = 'block';
            markdownView.style.display = 'none';
            editBtn.innerHTML = '<i class="fas fa-eye"></i> View';
        } else {
            // Switch to view mode - update the rendered markdown
            markdownView.innerHTML = marked.parse(textarea.value);
            textarea.style.display = 'none';
            markdownView.style.display = 'block';
            editBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
        }
    }
    
    async function saveNotebook(notebookName) {
        const cellsContainer = document.getElementById('cells-container');
        if (!cellsContainer) {
            showAlert('No notebook is currently open', 'warning');
            return;
        }
        
        // Collect all cells data
        const cells = [];
        for (let i = 0; i < cellsContainer.children.length; i++) {
            const cellElement = cellsContainer.children[i];
            const select = cellElement.querySelector('select');
            
            if (select) {
                // Get the CodeMirror editor or textarea depending on cell type
                let sourceValue = '';
                if (select.value === 'code') {
                    // For code cells, get value from CodeMirror editor if it exists
                    const cmEditor = cellElement.querySelector('.CodeMirror');
                    if (cmEditor) {
                        const cmInstance = cmEditor.CodeMirror;
                        sourceValue = cmInstance.getValue();
                    } else {
                        // Fallback to textarea if CodeMirror not initialized
                        const textarea = cellElement.querySelector('textarea');
                        sourceValue = textarea ? textarea.value : '';
                    }
                } else {
                    // For markdown cells, get value from textarea
                    const textarea = cellElement.querySelector('textarea');
                    sourceValue = textarea ? textarea.value : '';
                }
                
                cells.push({
                    cell_type: select.value,
                    source: sourceValue.split('\n').map(line => line + '\n'),
                    outputs: []
                });
            }
        }
        
        // Create notebook content structure
        const notebookContent = {
            cells: cells,
            metadata: {
                kernelspec: {
                    display_name: "Python 3",
                    language: "python",
                    name: "python3"
                },
                language_info: {
                    name: "python",
                    version: "3.9.0"
                }
            },
            nbformat: 4,
            nbformat_minor: 4
        };
        
        try {
            await saveNotebookContent(notebookName, notebookContent);
            showAlert(`Notebook ${notebookName} saved successfully`, 'success');
        } catch (error) {
            showAlert(`Failed to save notebook: ${error.message}`, 'danger');
        }
    }
    
    async function saveNotebookContent(notebookName, content) {
        // This function will make the API call to save the notebook
        await saveNotebookToServer(notebookName, content);
    }
    
    async function startKernel() {
        const status = document.getElementById('kernel-status');
        status.textContent = 'Starting...';
        status.className = 'kernel-status running';
        
        try {
            const response = await apiRequest('/api/v1/kernels', 'POST');
            currentKernelId = response.kernel_id;
            
            status.textContent = 'Running';
            status.className = 'kernel-status running';
            
            showAlert('Kernel started successfully', 'success');
        } catch (error) {
            status.textContent = 'Error';
            status.className = 'kernel-status error';
            
            showAlert(`Failed to start kernel: ${error.message}`, 'danger');
        }
    }
    
    async function stopKernel() {
        if (!currentKernelId) {
            showAlert('No kernel is currently running', 'warning');
            return;
        }
        
        const status = document.getElementById('kernel-status');
        status.textContent = 'Stopping...';
        status.className = 'kernel-status running';
        
        try {
            await apiRequest(`/api/v1/kernels/${currentKernelId}`, 'DELETE');
            currentKernelId = null;
            
            status.textContent = 'Idle';
            status.className = 'kernel-status idle';
            
            showAlert('Kernel stopped successfully', 'info');
        } catch (error) {
            status.textContent = 'Error';
            status.className = 'kernel-status error';
            
            showAlert(`Failed to stop kernel: ${error.message}`, 'danger');
        }
    }
    
    // Function to initialize CodeMirror editors for all code cells
    function initializeCodeMirrorEditors() {
        const cellsContainer = document.getElementById('cells-container');
        if (!cellsContainer) return;
        
        // Find all code cell textareas
        const codeCellTextareas = cellsContainer.querySelectorAll('.code-cell');
        
        codeCellTextareas.forEach((textarea, index) => {
            const cellElement = textarea.closest('.notebook-cell');
            initializeCodeMirrorForElement(cellElement);
        });
    }
    
    // Function to initialize CodeMirror for a specific cell element
    function initializeCodeMirrorForElement(cellElement) {
        const textarea = cellElement.querySelector('.code-cell');
        if (!textarea) return;
        
        // Initialize CodeMirror
        const cm = CodeMirror.fromTextArea(textarea, {
            mode: 'python',
            theme: 'dracula',
            lineNumbers: true,
            indentUnit: 4,
            tabSize: 4,
            indentWithTabs: false,
            extraKeys: {
                Tab: function(cm) {
                    cm.replaceSelection('    ', 'end');
                    return true;
                }
            }
        });
        
        // Store reference to the CodeMirror instance
        const cellIndex = parseInt(cellElement.dataset.cellIndex);
        codeMirrorEditors[cellIndex] = cm;
    }
</script>
{% endblock %}